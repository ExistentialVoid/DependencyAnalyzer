using System.Collections.Generic;
using System.Reflection;

namespace DependencyAnalyzer
{
    public abstract class ReferenceInfo
    {
        public string FullName => Host is TypeInfo t ? t.FullName : $"{Host.DeclaringType?.FullName}.{Host.Name}";
        internal bool IsClosure => Host.Name.Contains(">c__DisplayClass");
        internal bool IsCompilerClass => Host.Name.Equals("<>c");
        /// <summary>
        /// This member is auto-generated by the compiler (including static constructors, .cctor)
        /// </summary>
        internal bool IsCompilerGenerated
        {
            get
            {
                string name = Host is TypeInfo t ? t.FullName ?? t.Name : Host.Name;
                return name.Contains('>') || name.Contains(".cctor");
            }
        }
        public bool IsNested => Host is TypeInfo t && t.IsNested; 
        public MemberInfo Host { get; }
        /// <summary>
        /// The member presented similar to how it appears in source code
        /// </summary>
        public string Signature
        {
            get
            {
                if (_cachedSignature.Equals(string.Empty)) _cachedSignature = SignatureBuilder.GetSignature(Host);
                return _cachedSignature;
            }
        }

        private string _cachedSignature = string.Empty;


        public ReferenceInfo(MemberInfo member)
        {
            Host = member;
        }


        internal abstract void FindReferencedMembers(IEnumerable<ClassReferenceInfo> referenceTypes);
        internal abstract void FindReferencingMembers(IEnumerable<ClassReferenceInfo> referenceTypes);
    }
}
