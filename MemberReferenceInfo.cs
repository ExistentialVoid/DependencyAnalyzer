using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

namespace DependencyAnalyzer
{
    /// <summary>
    /// Couples a member with other members the it references and that reference it
    /// </summary>
    public sealed class MemberReferenceInfo
    {
        /// <summary>
        ///This member is a compiler-generated closure with naming "<>c"
        /// </summary>
        internal bool IsClosure => Member.Name.Contains(">c__DisplayClass");
        /// <summary>
        /// This member is auto-generated by the compiler (including static constructors, .cctor)
        /// </summary>
        internal bool IsCompilerGenerated
        {
            get
            {
                string name = Member is TypeInfo t ? t.FullName : Member.Name;
                return name.Contains('>') || name.Contains(".cctor");
            }
        }
        public MemberInfo Member => _member;
        public IReadOnlyDictionary<MemberInfo, int> ReferencedMembers => _referencedMembers;
        public IReadOnlyDictionary<MemberInfo, int> ReferencingMembers => _referencingMembers;
        /// <summary>
        /// The member presented similar to how it appears in source code
        /// </summary>
        public string Signature
        {
            get
            {
                if (_cachedSignature == null)
                {
                    SignatureBuilder sig = new();
                    _cachedSignature = sig.GetSignature(_member);
                }
                return _cachedSignature;
            }
        }

        private Dictionary<MemberInfo, int> _referencingMembers = null;
        private string _cachedSignature = null;
        private readonly MemberInfo _member;
        private readonly Dictionary<MemberInfo, int> _referencedMembers = new();


        public MemberReferenceInfo(MemberInfo referencingMember)
        {
            _member = referencingMember;
        }


        internal void AddReferencedMember(MemberInfo member)
        {
            MemberInfo existingRef = _referencedMembers
                                        .ToList()
                                        .Find(m => m.Key.HasSameMetadataDefinitionAs(member))
                                        .Key;

            if (existingRef != null) _referencedMembers[existingRef]++;
            else if (!(member is TypeInfo type && _member.DeclaringType.HasSameMetadataDefinitionAs(type)) &&
                (!member.DeclaringType?.HasSameMetadataDefinitionAs(_member.DeclaringType) ?? true)) _referencedMembers.Add(member, 1);
        }
        private void AddReferencingMember(MemberInfo member)
        {
            MemberInfo existingRef = _referencingMembers
                                        .ToList()
                                        .Find(m => m.Key.HasSameMetadataDefinitionAs(member)).Key;

            if (existingRef != null) _referencingMembers[existingRef]++;
            else _referencingMembers.Add(member, 1);
        }
        internal void FindReferencedMembers(IEnumerable<ClassReferenceInfo> referenceTypes)
        {
            MemberInterpreter interpreter = new(referenceTypes.ToList().ConvertAll(c => c.Class));
            List<MemberInfo> referencedMembers = interpreter.GetReferencedMembers(_member);
            
            foreach (var member in referencedMembers) AddReferencedMember(member);
        }
        internal void FindReferencingMembers(IEnumerable<ClassReferenceInfo> referenceTypes)
        {
            _referencingMembers = new();

            var flattenedMembers = referenceTypes.AsQueryable().SelectMany(t => t.Members.ToList()).ToList();
            foreach (var member in flattenedMembers)
            {
                Func<MemberInfo, bool> matchedMember = m => m.Name.Equals(_member.Name) || m.Name.Contains($"et_{_member.Name}");
                if (member.ReferencedMembers.Keys.Any(matchedMember)) AddReferencingMember(member.Member);
            }
        }
        /// <summary>
        /// Check if member is a compiler generated method.
        /// </summary>
        /// <param name="methodName"></param>
        /// <returns>True if name contains ">b__", otherwise false.</returns>
        internal bool IsAnonomous(out string methodName)
        {
            if (Member.Name.Contains(">b__"))
            {
                methodName = Member.Name.Split('>')[0].TrimStart('<');
                return true;
            }

            methodName = null;
            return false;
        }
        /// <summary>
        /// Check if member is a compiler generated underlying field of an auto-property.
        /// </summary>
        /// <param name="propertyName"></param>
        /// <returns>True if name contains ">k__BackingField", otherwise false.</returns>
        internal bool IsBackingField(out string propertyName)
        {
            if (Member.Name.Contains(">k__BackingField"))
            {
                propertyName = Member.Name.Split('>')[0].TrimStart('<');
                return true;
            }

            propertyName = null;
            return false;
        }
        /// <summary>
        /// Check if member is the get method of a property.
        /// </summary>
        /// <param name="propertyName"></param>
        /// <returns>True if name contains "get_", otherwise false.</returns>
        internal bool IsGetter(out string propertyName)
        {
            if (Member.Name.Contains("get_"))
            {
                propertyName = Member.Name.Replace("get_", string.Empty);
                return true;
            }

            propertyName = null;
            return false;
        }
        /// <summary>
        /// Check if member is the set method of a property.
        /// </summary>
        /// <param name="propertyName"></param>
        /// <returns>True if name contains "set_", otherwise false.</returns>
        internal bool IsSetter(out string propertyName)
        {
            if (Member.Name.Contains("set_"))
            {
                propertyName = Member.Name.Replace("set_", string.Empty);
                return true;
            }

            propertyName = null;
            return false;
        }
        public override string ToString()
        {
            string info = $"[{_member.MemberType}] ";
            info += _member.DeclaringType is null ? string.Empty : _member.DeclaringType.FullName + '.';
            info += _member is Type type ? type.FullName : _member.Name;
            return info;
        }
    }
}
